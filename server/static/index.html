<!doctype html>
<html lang="es">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Centro de control Santa María</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #f8fafc;
      --surface: #ffffff;
      --muted: #6b7280;
      --accent: #2563eb;
      --accent-2: #06b6d4;
      --ok: #10b981;
      --warn: #f59e0b;
      --danger: #ef4444;
      --radius: 12px;
      --gap: 16px;
      --card-shadow: 0 8px 24px rgba(15, 23, 42, 0.06);
    }

    * {
      box-sizing: border-box
    }

    #modalResult {
      white-space: pre-wrap;
      /* preserva saltos y wrap */
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Courier New", monospace;
      font-size: 13px;
      color: var(--muted);
      margin-top: 6px;
    }

    html,
    body {
      height: 100%
    }

    body {
      margin: 0;
      font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, 'Helvetica Neue', Arial;
      background: var(--bg);
      color: #0f1724;
      padding: 24px;
      display: flex;
      align-items: flex-start;
      justify-content: center
    }

    .wrap {
      width: 100%;
      max-width: 1100px
    }

    /* Login overlay */
    #authOverlay {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(15, 23, 36, 0.03);
      z-index: 40;
      padding: 20px
    }

    .loginCard {
      width: 100%;
      max-width: 420px;
      background: var(--surface);
      border-radius: 14px;
      padding: 28px;
      box-shadow: var(--card-shadow);
      border: 1px solid rgba(15, 23, 42, 0.04)
    }

    .logoCircle {
      width: 56px;
      height: 56px;
      border-radius: 12px;
      background: linear-gradient(135deg, var(--accent), var(--accent-2));
      display: grid;
      place-items: center;
      color: white;
      font-weight: 700;
      margin-bottom: 12px
    }

    h1 {
      margin: 0;
      font-size: 20px
    }

    p.lead {
      margin: 6px 0 18px;
      color: var(--muted);
      font-size: 14px
    }

    label {
      display: block;
      font-size: 13px;
      color: var(--muted);
      margin-bottom: 8px
    }

    input,
    textarea,
    select {
      width: 100%;
      padding: 12px 14px;
      border-radius: 10px;
      border: 1px solid rgba(15, 23, 42, 0.06);
      background: transparent;
      font-size: 14px
    }

    input:focus,
    textarea:focus,
    select:focus {
      outline: none;
      box-shadow: 0 8px 30px rgba(37, 99, 235, 0.06);
      border-color: rgba(37, 99, 235, 0.12)
    }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 10px 14px;
      border-radius: 10px;
      border: 0;
      cursor: pointer;
      font-weight: 600
    }

    .btn-primary {
      background: linear-gradient(90deg, var(--accent), var(--accent-2));
      color: white
    }

    .btn-ghost {
      background: transparent;
      border: 1px solid rgba(15, 23, 42, 0.06);
      color: var(--muted)
    }

    main.app {
      display: none
    }

    .topBar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px
    }

    .titleArea {
      display: flex;
      gap: 12px;
      align-items: center
    }

    .small {
      font-size: 13px;
      color: var(--muted)
    }

    .layout {
      display: grid;
      grid-template-columns: 1fr 320px;
      gap: 16px
    }

    @media(max-width:900px) {
      .layout {
        grid-template-columns: 1fr
      }
    }

    /* Clients grid */
    .clients-card {
      background: var(--surface);
      border-radius: 12px;
      padding: 16px;
      border: 1px solid rgba(15, 23, 42, 0.04);
      box-shadow: var(--card-shadow)
    }

    .clients-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
      gap: 12px;
      margin-top: 12px
    }

    .clientTile {
      background: linear-gradient(180deg, rgba(2, 6, 23, 0.02), transparent);
      padding: 12px;
      border-radius: 12px;
      border: 1px solid rgba(15, 23, 42, 0.04);
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 8px;
      transition: transform .12s ease, box-shadow .12s ease
    }

    .clientTile:hover {
      transform: translateY(-6px);
      box-shadow: 0 12px 30px rgba(15, 23, 42, 0.06)
    }

    .clientId {
      font-weight: 700;
      font-size: 14px;
      color: #0b1320
    }

    .clientName {
      font-size: 12px;
      color: var(--muted)
    }

    .statusBadge {
      padding: 6px 8px;
      border-radius: 999px;
      font-size: 12px;
      background: rgba(16, 185, 129, 0.08);
      color: var(--ok);
      border: 1px solid rgba(16, 185, 129, 0.12);
    }

    .offlineBadge {
      background: rgba(239, 68, 68, 0.06);
      color: var(--danger);
      border: 1px solid rgba(239, 68, 68, 0.08);
      justify-content: flex-end;
    }

    /* Card for send to all */
    .allTile {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 16px
    }

    .allIcon {
      width: 44px;
      height: 44px;
      border-radius: 10px;
      background: linear-gradient(135deg, var(--accent), var(--accent-2));
      display: grid;
      place-items: center;
      color: white;
      font-weight: 700;
      margin-bottom: 8px
    }

    /* Right column */
    .controls {
      display: flex;
      flex-direction: column;
      gap: 12px
    }

    .stat {
      background: var(--surface);
      padding: 12px;
      border-radius: 10px;
      text-align: center;
      border: 1px solid rgba(15, 23, 42, 0.04)
    }

    pre {
      background: transparent;
      color: var(--muted);
      padding: 10px;
      border-radius: 8px;
      white-space: pre-wrap;
      margin: 0;
      max-height: 260px;
      overflow: auto;
      border: 1px dashed rgba(15, 23, 42, 0.04)
    }


    /* Modal */
    .modalOverlay {
      position: fixed;
      inset: 0;
      background: rgba(2, 6, 23, 0.45);
      display: none;
      z-index: 60;
      padding: 20px;
      align-items: center;
      justify-content: center;
      overflow: auto
    }

    .modal {
      width: 100%;
      max-width: 800px;
      /* límite máximo en pantallas grandes */
      min-width: 400px;
      /* da un ancho mínimo razonable en PC */
      background: var(--surface);
      border-radius: 12px;
      margin: auto;
      padding: 28px;
      box-shadow: 0 18px 60px rgba(2, 6, 23, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.05);
      max-height: calc(100vh - 60px);
      overflow-y: auto;
      transition: all 0.25s ease;
    }

    /* Adaptativo para móvil */
    @media (max-width: 500px) {
      .modal {
        min-width: unset;
        /* evita forzar ancho grande */
        max-width: calc(100vw - 40px);
        /* ocupa casi toda la pantalla */
        padding: 18px 20px;
      }
    }

    .modal h3 {
      margin: 0 0 8px 0
    }

    .modal .row {
      display: flex;
      gap: 10px
    }

    .modal .tabs {
      display: flex;
      gap: 8px;
      margin-bottom: 10px
    }

    .tab {
      padding: 8px 12px;
      border-radius: 8px;
      background: transparent;
      border: 1px solid transparent;
      cursor: pointer
    }

    .tab.active {
      background: linear-gradient(90deg, var(--accent), var(--accent-2));
      color: white
    }

    .screenContainer {
      display: flex;
      flex-direction: column;
      gap: 10px
    }

    /* Updated screenFrame to avoid cropping and show placeholder */
    .screenFrame {
      width: 100%;
      max-height: 80vh;
      /* no ocupará más que la ventana */
      min-height: 260px;
      /* <-- evita el colapso: se verá como área grande */
      background: #111;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      padding: 12px;
      box-sizing: border-box;
      position: relative;
    }

    /* Placeholder shown before any frame is available */
    .screenPlaceholder {
      width: 100%;
      height: 100%;
      min-height: 220px;
      /* asegura espacio vertical para el placeholder */
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 8px;
      color: rgba(255, 255, 255, 0.85);
      text-align: center;
      font-size: 14px;
      pointer-events: auto;
      /* permitir clicks (útil si quieres disparar start al click) */
      box-sizing: border-box;
      padding: 8px;
      transition: opacity .18s ease;
    }

    .screenPlaceholder .mutedLine {
      color: rgba(255, 255, 255, 0.6);
      font-weight: 400;
      font-size: 13px;
    }

    .screenPlaceholder svg {
      width: 72px;
      height: 72px;
      opacity: 0.95
    }

    /* new: spinner overlay centered in screenFrame */
    .screenSpinner {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 56px;
      height: 56px;
      border-radius: 50%;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 5;
      background: rgba(0, 0, 0, 0.35);
      backdrop-filter: blur(2px);
    }

    .screenSpinner::after {
      content: "";
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: 4px solid rgba(255, 255, 255, 0.12);
      border-top-color: rgba(255, 255, 255, 0.95);
      animation: spin 1s linear infinite;
      display: block;
      box-sizing: border-box;
    }

    .logoIcon {
      width: 36px;
      height: 36px;
      border-radius: 8px;
      object-fit: contain;
      padding: 5px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
    }

    @keyframes spin {
      from {
        transform: rotate(0deg);
      }

      to {
        transform: rotate(360deg);
      }
    }

    .screenFrame img {
      width: auto;
      height: auto;
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      display: none;
      /* hidden until a frame is set */
      z-index: 3;
      position: relative;
    }

    @media(max-width:480px) {
      body {
        padding: 12px
      }

      .clients-grid {
        grid-template-columns: repeat(2, 1fr)
      }
    }

    /* Estilos para la sección de tipo de mensaje - más compacta y alineada */
    .message-type-section {
      margin-top: 8px;
      font-size: 13px;
      /* tamaño reducido */
      color: var(--muted);
    }

    .message-type-row {
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: nowrap;
      /* evitar que salten líneas */
      white-space: nowrap;
      overflow: hidden;
    }

    .message-type-row label {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      border-radius: 8px;
      cursor: pointer;
      border: 1px solid transparent;
      transition: background .12s ease, border-color .12s ease;
    }

    /* apariencia sutil al foco/hover */
    .message-type-row label:hover {
      background: rgba(37, 99, 235, 0.04);
      border-color: rgba(15, 23, 42, 0.04);
    }

    .message-type-row input[type="radio"] {
      width: 14px;
      height: 14px;
      margin: 0;
      accent-color: var(--accent);
    }

    /* input para segundos compacto */
    #modalTimeout {
      width: 86px;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid rgba(15, 23, 42, 0.06);
      font-size: 13px;
      box-sizing: border-box;
      margin-left: 6px;
    }

    /* Si el ancho es muy pequeño, permitir que el timeout salte a la siguiente línea sin romper todo */
    @media (max-width: 520px) {
      .message-type-row {
        flex-wrap: wrap;
        gap: 8px;
      }

      #modalTimeout {
        width: 100%;
        margin-left: 0;
      }
    }

    /* Botones: dejar igual pero asegurando tamaño compacto */
    .message-type-section .btn {
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 13px;
    }

    /* ===== Alineación vertical perfecta para los radios + labels ===== */
    #panelCmd .cmd-mode-row {
      display: flex;
      gap: 10px;
      align-items: center;
      /* centra verticalmente todos los hijos */
      white-space: nowrap;
      flex-wrap: nowrap;
      font-size: 13px;
      line-height: 1;
      /* evita alturas inesperadas */
      margin-top: 6px;
    }

    /* Hacemos que cada par radio+texto se comporte como un elemento centrado */
    #panelCmd .cmd-mode-row .cmd-item {
      display: inline-flex;
      align-items: center;
      /* centra texto y radio */
      gap: 8px;
      padding: 4px 8px;
      border-radius: 8px;
      cursor: pointer;
      color: var(--muted);
      user-select: none;
      line-height: 1;
      /* asegurar línea compacta */
    }

    /* Radio pequeño y perfectamente alineado */
    #panelCmd .cmd-mode-row input[type="radio"] {
      width: 16px;
      height: 16px;
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      vertical-align: middle;
      accent-color: var(--accent);
      flex-shrink: 0;
    }

    /* Ajustes del texto del label para mantenerlo centrado */
    #panelCmd .cmd-mode-row label {
      margin: 0;
      padding: 0;
      cursor: pointer;
      font-size: 13px;
      display: inline-flex;
      align-items: center;
      line-height: 1;
    }

    /* Hover sutil */
    #panelCmd .cmd-mode-row .cmd-item:hover {
      background: rgba(37, 99, 235, 0.04);
      border-color: rgba(15, 23, 42, 0.04);
    }

    /* Respeta pequeñas pantallas (permitir wrap si necesario) */
    @media (max-width: 520px) {
      #panelCmd .cmd-mode-row {
        flex-wrap: wrap;
        gap: 8px;
        font-size: 12px;
      }

      #panelCmd .cmd-mode-row .cmd-item {
        padding: 6px 10px;
      }
    }

    /* ---------- Tarjeta base (cuadrada) ---------- */
    .clientTile {
      position: relative;
      background: var(--surface);
      border-radius: 12px;
      padding: 12px;
      border: 1px solid rgba(15, 23, 42, 0.04);
      box-shadow: var(--card-shadow);
      transition: transform .14s cubic-bezier(.2, .9, .2, 1), box-shadow .14s cubic-bezier(.2, .9, .2, 1);
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 12px;
      overflow: hidden;
      will-change: transform, box-shadow;

      /* Fuerza proporción cuadrada según ancho externo */
      aspect-ratio: 1 / 1;
      min-width: 160px;
      /* ajusta al tamaño que necesites en tu grid */
      box-sizing: border-box;
    }

    /* checkbox absoluta en la esquina superior izquierda */
    .clientTileCheckbox {
      position: absolute;
      top: 12px;
      left: 12px;
      width: 20px;
      height: 20px;
      margin: 0;
      accent-color: var(--accent);
      z-index: 6;
      cursor: pointer;
      border-radius: 6px;
      border: 1px solid rgba(15, 23, 42, 0.06);
      background: transparent;
      opacity: 0;
      transform: translateY(-6px) scale(.96);
      transition: opacity .18s ease, transform .18s cubic-bezier(.2, .9, .2, 1);
      pointer-events: none;
    }

    /* mostrar checkbox en hover/focus (igual comportamiento) */
    .clientTile:hover .clientTileCheckbox,
    .clientTile:focus-within .clientTileCheckbox,
    .clientTile.show-checkbox .clientTileCheckbox {
      opacity: 1;
      transform: translateY(0) scale(1);
      pointer-events: auto;
    }

    /* contenido: deja espacio para la checkbox (padding-left) */
    .clientContent {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      width: 100%;
      min-width: 0;
      padding-left: 48px;
      /* reserva espacio visual para la checkbox absoluta */
      box-sizing: border-box;
      gap: 12px;
    }

    /* columna con id/nombre/detalle y badge debajo */
    .clientMeta {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: flex-start;
      gap: 4px;
      min-width: 0;
    }

    /* ID, nombre, detalle (como tenías) */
    .clientId {
      font-weight: 600;
      font-size: 13px;
      color: var(--muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .clientName {
      font-weight: 800;
      font-size: 17px;
      color: #0b1320;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      line-height: 1;
    }

    .clientSmallHost {
      font-size: 12px;
      color: rgba(15, 23, 42, 0.45);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* badge debajo del texto */
    .clientMeta .statusBadge {
      margin-top: 8px;
      align-self: flex-start;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 700;
      display: inline-block;
      text-align: center;
      min-width: 66px;
    }

    /* variantes de estado */
    .statusBadge.online {
      background: rgba(16, 185, 129, 0.08);
      color: var(--ok);
      border: 1px solid rgba(16, 185, 129, 0.12);
    }

    .statusBadge.offline {
      background: rgba(239, 68, 68, 0.06);
      color: var(--danger);
      border: 1px solid rgba(239, 68, 68, 0.08);
    }

    /* ---------- Variante para "Enviar a todos" (centrado) ---------- */
    /* Aplica: <div class="clientTile broadcastTile"> ... </div> */
    .clientTile.broadcastTile {
      /* conserva aspecto cuadrado, pero centra todo */
      display: flex;
      align-items: center;
      justify-content: center;
      padding-left: 12px;
      /* menos padding reservado porque el contenido se centra */
      padding-right: 12px;
    }

    /* el contenido centrado en columna */
    .clientTile.broadcastTile .clientContent {
      padding-left: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    /* el meta centrado (texto centrado) */
    .clientTile.broadcastTile .clientMeta {
      align-items: center;
      text-align: center;
      padding-top: 4px;
      /* centra visual con la checkbox */
    }

    /* badge centrada bajo el texto */
    .clientTile.broadcastTile .clientMeta .statusBadge {
      align-self: center;
      margin-top: 6px;
    }

    /* Si la tarjeta "Enviar a todos" tiene un icono cuadrado grande (ejemplo) */
    .clientTile.broadcastTile .icon {
      width: 56px;
      height: 56px;
      border-radius: 12px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-weight: 800;
    }

    /* responsive: mantener proporción y ajustar tamaños */
    @media (max-width: 480px) {
      .clientTile {
        min-width: 140px;
        padding: 10px;
      }

      .clientTileCheckbox {
        top: 10px;
        left: 10px;
        width: 18px;
        height: 18px;
      }

      .clientContent {
        padding-left: 42px;
        gap: 8px;
      }

      .clientName {
        font-size: 15px;
      }

      .clientId {
        font-size: 12px;
      }

      .clientSmallHost {
        font-size: 11px;
      }

      .clientMeta .statusBadge {
        font-size: 11px;
        padding: 4px 7px;
        min-width: 62px;
      }

      .clientTile.broadcastTile .icon {
        width: 48px;
        height: 48px;
      }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <!-- Login overlay -->
    <div id="authOverlay">
      <div class="loginCard">
        <div class="logoCircle">RM</div>
        <h1>Iniciar sesión</h1>
        <p class="lead">Accede para ver y controlar tus clientes remotos.</p>
        <label for="username">Usuario</label>
        <input id="username" placeholder="usuario" autocomplete="username" />
        <label for="password">Contraseña</label>
        <input id="password" type="password" placeholder="contraseña" autocomplete="current-password" />
        <div style="display:flex;gap:10px;margin-top:12px">
          <button class="btn btn-primary" onclick="login()">Entrar</button>
          <button class="btn btn-ghost" onclick="fillDemo()">Demo</button>
        </div>
        <div id="loginStatus" class="small" style="margin-top:10px"></div>
      </div>
    </div>

    <main class="app">
      <div class="topBar">
        <div class="titleArea">
          <img src="/server/static/logo.png" alt="Logo IS" class="logoIcon">
          <h2 style="margin:0">IS Santa María</h2>
          <div class="small">Centro de control</div>
        </div>
        <div style="display:flex;align-items:center">
          <div class="small" style="margin-right:12px">Estado: <strong id="statusText">desconectado</strong></div>
          <button id="manageUsersBtn" class="btn btn-ghost" style="margin-left:8px"
            onclick="window.location.href='/static/users.html'">Gestionar usuarios</button>

          <!-- logout button inserted dynamically -->
        </div>
      </div>

      <div class="layout">
        <section class="clients-card">
          <div style="display:flex;gap:8px;align-items:center;justify-content:space-between">
            <div>
              <label class="small">Buscar</label>
              <input id="filterInput" placeholder="Buscar por id, nombre o host" oninput="applyFilter()" />
            </div>
            <div style="display:flex;gap:8px;align-items:center">
              <button class="btn btn-ghost" onclick="refreshClients()">Actualizar</button>

              <!-- Botones para selección múltiple -->
              <button id="sendSelectedBtn" class="btn btn-primary" style="display:none;margin-left:8px"
                onclick="openModalForSelected()">
                Enviar a seleccionados (<span id="selectedCount">0</span>)
              </button>
              <button id="clearSelectedBtn" class="btn btn-ghost" style="display:none;margin-left:8px"
                onclick="clearSelection()">
                Limpiar selección
              </button>
            </div>
          </div>


          <div class="clients-grid" id="clientsGrid">
            <!-- client cards rendered here -->
          </div>
        </section>

        <aside class="controls">
          <div class="stat">
            <div style="font-size:12px;color:var(--muted)">Conectados</div>
            <div id="connectedCount" style="font-size:20px;font-weight:700">0</div>
          </div>
          <div class="stat">
            <div style="font-size:12px;color:var(--muted)">Total</div>
            <div id="totalCount" style="font-size:20px;font-weight:700">0</div>
          </div>
          <div class="stat">
            <div style="font-size:12px;color:var(--muted);margin-bottom:8px">Logs</div>
            <pre id="logArea">Sin registros.</pre>
          </div>
        </aside>
      </div>

      <!-- La sección de "Atajos rápidos" fue eliminada a petición -->
    </main>
  </div>

  <!-- Modal -->
  <div id="modalOverlay" class="modalOverlay">
    <div class="modal">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
        <div>
          <h3 id="modalTitle">Cliente</h3>
          <div class="small" id="modalSub">ID: -</div>
        </div>
        <div><button class="btn btn-ghost" onclick="closeModal()">Cerrar</button></div>
      </div>

      <div class="tabs">
        <div id="tabMsg" class="tab active" onclick="switchTab('msg')">Mensaje</div>
        <div id="tabCmd" class="tab" onclick="switchTab('cmd')">Comando</div>
        <div id="tabScreen" class="tab" onclick="switchTab('screen')">Pantalla</div>
      </div>

      <div id="modalBody">
        <!-- message -->
        <div id="panelMsg">
          <label class="small">Mensaje</label>
          <textarea id="modalMessage" placeholder="Mensaje para el cliente"></textarea>
          <!-- INICIO: tipo de mensaje (pegar aquí, dentro de #panelMsg, debajo del textarea) -->
          <div class="message-type-section">
            <label class="small">Tipo de mensaje</label>

            <div class="message-type-row" role="radiogroup" aria-label="Tipo de mensaje">
              <label title="Mensaje fijo (no desaparece)">
                <input type="radio" name="messageType" value="fixed" checked aria-checked="true"> Mensaje fijo
              </label>

              <label title="Mensaje temporal (desaparece después de N segundos)">
                <input type="radio" name="messageType" value="temporary" aria-checked="false"> Mensaje temporal
              </label>

              <input type="number" id="modalTimeout" name="timeout" placeholder="Segundos" min="1" disabled
                aria-label="Segundos para mensaje temporal">

              <label title="Mensaje oculto (se muestra solo al pulsar ver)">
                <input type="radio" name="messageType" value="hidden" aria-checked="false"> Mensaje oculto
              </label>
            </div>

            <div style="display:flex;gap:8px;margin-top:8px">
              <button class="btn btn-primary" id="sendMessageBtn" onclick="sendMessageModal()">Enviar mensaje</button>
              <button class="btn btn-ghost" type="button"
                onclick="document.getElementById('modalMessage').value='';">Limpiar</button>
            </div>
          </div>
          <!-- FIN: tipo de mensaje -->

        </div>

        <!-- command -->
        <div id="panelCmd" style="display:none">
          <label class="small">Comando</label>

          <div class="cmd-mode-row">
            <span class="cmd-item">
              <input id="cmdRadioExec" type="radio" name="cmdMode" value="exec" checked />
              <label for="cmdRadioExec">Ejecutar comando</label>
            </span>

            <span class="cmd-item">
              <input id="cmdRadioUrl" type="radio" name="cmdMode" value="url" />
              <label for="cmdRadioUrl">Abrir enlace en cliente</label>
            </span>
          </div>

          <div style="margin-top:8px;display:flex;flex-direction:column;gap:8px">
            <!-- comando -->
            <div id="cmdExecArea">
              <input id="modalCmdInput" placeholder="Comando a ejecutar" />
              <label class="small" style="margin-top:6px">Timeout (segundos)</label>
              <input id="modalCmdTimeout" placeholder="10" />
            </div>

            <!-- url -->
            <div id="cmdUrlArea" style="display:none">
              <label class="small">URL (incluye http/https)</label>
              <input id="modalCmdUrl" placeholder="https://example.com" />
              <div class="small" style="color:var(--muted)">Nota: el enlace se abrirá en el navegador del cliente
                automáticamente.</div>
            </div>

            <div style="display:flex;gap:8px;margin-top:8px">
              <button class="btn btn-primary" id="execBtn" onclick="execCommandModal()">Enviar</button>
              <button type="button" class="btn btn-ghost" onclick="clearExecModal()">Limpiar</button>
            </div>
          </div>
        </div>

        <!-- screen -->
        <div id="panelScreen" style="display:none">
          <div class="screenContainer">
            <div style="display:flex;gap:8px;align-items:center">
              <button class="btn btn-primary" id="startScreenBtn" onclick="startScreenStream()">Iniciar
                transmisión</button>
              <button class="btn btn-ghost" id="stopScreenBtn" onclick="stopScreenStream()">Detener transmisión</button>
              <div class="small" style="margin-left:auto">FPS: <input id="screenFps"
                  style="width:60px;margin-left:6px;padding:6px;border-radius:8px;border:1px solid rgba(15,23,42,0.06)"
                  value="2" /></div>
            </div>

            <!-- Updated screen frame: placeholder + img + spinner -->
            <div class="screenFrame">
              <div id="screenPlaceholder" class="screenPlaceholder" aria-hidden="false">
                <!-- Laptop SVG icon -->
                <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                  <rect x="2.5" y="4.5" width="19" height="12" rx="1.5" stroke="currentColor" stroke-width="1.5"
                    fill="none" />
                  <rect x="6" y="8" width="12" height="6" fill="currentColor" opacity="0.06" />
                  <path d="M3 18h18" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" />
                  <path d="M8 21h8" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" />
                </svg>
                <div style="color:rgba(255,255,255,0.85);font-weight:600">Pantalla del cliente</div>
                <div class="mutedLine">Presiona "Iniciar transmisión" para mostrar la pantalla</div>
              </div>

              <img id="screenImg" src="" alt="Pantalla del cliente" />

              <!-- Spinner: visible mientras esperamos primer frame / entre frames -->
              <div id="screenSpinner" class="screenSpinner" aria-hidden="true"></div>
            </div>

            <div class="small">Consejo: inicia la transmisión desde aquí y luego la vista se actualizará
              automáticamente.</div>
          </div>
        </div>
      </div>

      <div id="modalResult" style="margin-top:12px;color:var(--muted)"></div>
    </div>
  </div>

  <script>
    // ------------------------
    // Globals
    // ------------------------
    let token = null;
    let role = null;
    let latestClients = [];
    let currentTarget = null; // client_id or 'ALL'
    let screenInterval = null;
    let previousObjectUrl = null;
    let screenRefreshId = 0;

    // ------------------------
    // Helper: renderizar respuesta en modalResult (maneja null/undefined/vacío)
    // ------------------------
    function renderResult(data) {
      const el = document.getElementById('modalResult');
      if (!el) return;

      // Si la respuesta es null/undefined o string vacío, mostramos mensaje claro
      if (data === null || data === undefined || data === '') {
        el.textContent = '(sin respuesta del servidor)';
        return;
      }

      let out = '';

      try {
        // Si data es string que contiene JSON, intentar parsearlo
        if (typeof data === 'string') {
          try { data = JSON.parse(data); } catch { /* no es JSON */ }
        }

        // Estructura esperada: { responses: { "<cliente>": { result: {...} } } }
        if (data && data.responses && typeof data.responses === 'object') {
          const all = [];
          for (const [client, info] of Object.entries(data.responses)) {
            const result = info.result || {};
            const stdout = (result.stdout || '').toString().trim();
            const stderr = (result.stderr || '').toString().trim();
            const header = `=== ${client} ===`;
            let section = stdout || '(sin salida)';
            if (stderr) section += `\n\nSTDERR:\n${stderr}`;
            all.push(`${header}\n${section}`);
          }
          out = all.join('\n\n');
        } else if (data && (data.stdout || data.stderr)) {
          out = (data.stdout || '') + (data.stderr ? `\n\nSTDERR:\n${data.stderr}` : '');
        } else if (typeof data === 'string') {
          out = data;
        } else {
          out = JSON.stringify(data, null, 2);
        }
      } catch (err) {
        out = `Error mostrando resultado: ${err}`;
      }

      el.textContent = out;
    }

    // ------------------------
    // Toggle comando vs URL (inicialización única)
    // ------------------------
    function initCmdUrlToggle() {
      const rExec = document.getElementById('cmdRadioExec');
      const rUrl = document.getElementById('cmdRadioUrl');
      const execArea = document.getElementById('cmdExecArea');
      const urlArea = document.getElementById('cmdUrlArea');
      const cmdInput = document.getElementById('modalCmdInput');
      const cmdTimeout = document.getElementById('modalCmdTimeout');
      const urlInput = document.getElementById('modalCmdUrl');

      function update() {
        const urlMode = rUrl && rUrl.checked;
        if (execArea) execArea.style.display = urlMode ? 'none' : 'block';
        if (urlArea) urlArea.style.display = urlMode ? 'block' : 'none';

        if (cmdInput) { cmdInput.disabled = !!urlMode; if (urlMode) cmdInput.value = ''; }
        if (cmdTimeout) { cmdTimeout.disabled = !!urlMode; if (urlMode) cmdTimeout.value = '10'; }
        if (urlInput) { urlInput.disabled = !urlMode; if (urlMode) urlInput.focus(); }
      }

      if (rExec && rUrl) {
        rExec.addEventListener('change', update);
        rUrl.addEventListener('change', update);
      }
      try { update(); } catch (e) { /* ignore */ }
    }

    // ------------------------
    // Exec command / open URL (una sola implementación robusta)
    // ------------------------
    async function execCommandModal() {
      const cmdEl = document.getElementById('modalCmdInput');
      const timeoutEl = document.getElementById('modalCmdTimeout');
      const urlEl = document.getElementById('modalCmdUrl');
      const radioUrl = document.getElementById('cmdRadioUrl');

      const isUrl = !!(radioUrl && radioUrl.checked);

      if (!currentTarget) { alert('Selecciona un cliente'); return; }

      const target = Array.isArray(currentTarget)
        ? currentTarget.slice()
        : (currentTarget === 'ALL'
          ? latestClients.map(c => c.client_id).filter(Boolean)
          : [currentTarget]);

      if (!target || target.length === 0) { alert('Selecciona un cliente'); return; }

      const sendBtn = document.getElementById('execBtn') || document.getElementById('sendMessageBtn');
      if (sendBtn) { sendBtn.disabled = true; sendBtn.style.opacity = '0.7'; }

      try {
        let res;
        if (isUrl) {
          let url = (urlEl ? urlEl.value || '' : '').trim();
          if (!url) { alert('Ingresa una URL.'); return; }
          if (!/^[a-zA-Z][a-zA-Z0-9+.\-]*:\/\//.test(url)) url = 'https://' + url;
          url = url.replace(/\s+/g, '');
          try { new URL(url); } catch (e) { alert('URL inválida: ' + e.message); return; }

          const payload = { client_ids: target, open_url: url };
          res = await authFetch('/exec', { method: 'POST', body: JSON.stringify(payload) });

        } else {
          const cmd = cmdEl ? (cmdEl.value || '').trim() : '';
          const timeout = timeoutEl ? (parseInt(timeoutEl.value, 10) || 10) : 10;
          if (!cmd) { alert('Escribe el comando a ejecutar.'); return; }

          const payload = { client_ids: target, command: cmd, timeout_seconds: timeout };
          res = await authFetch('/exec', { method: 'POST', body: JSON.stringify(payload) });
        }

        // Intentar parsear JSON de forma segura (res.clone())
        let parsed = null;
        try {
          parsed = await res.clone().json().catch(() => null);
        } catch (e) {
          parsed = null;
        }

        // Si no hay JSON, obtener texto
        let text = null;
        if (parsed === null) {
          text = await res.text().catch(() => '');
          // si text contiene JSON aunque no tuviera header correcto, intentamos parsearlo
          if (text) {
            try { parsed = JSON.parse(text); } catch (e) { /* queda texto */ }
          }
        }

        // Manejo de errores HTTP
        if (!res.ok) {
          const errBody = parsed !== null ? parsed : (text || `Error: ${res.status}`);
          renderResult(errBody);
          return;
        }

        // OK: si tenemos objeto JSON, lo renderizamos; si tenemos texto, lo mostramos
        if (parsed !== null) {
          // Detectar si es respuesta de apertura de URL
          const isUrlResponse =
            parsed.responses &&
            Object.values(parsed.responses).some(v => v === "sent" || typeof v === "string");

          if (isUrlResponse) {
            document.getElementById("modalResult").textContent = "✅ URL enviada correctamente";
          } else {
            renderResult(parsed);
          }
        } else if (text) {
          // mostrar texto plano (no JSON)
          renderResult(text);
        } else {
          // ni JSON ni texto: informar claramente
          document.getElementById('modalResult').textContent = '(sin contenido)';
        }

        // Log
        const log = document.getElementById('logArea');
        const now = new Date().toLocaleTimeString();
        if (isUrl) {
          if (log) log.textContent = `[${now}] Enlace enviado → ${target.length} cliente(s)\n` + log.textContent;
        } else {
          const cmd = cmdEl ? (cmdEl.value || '').trim() : '';
          if (log) log.textContent = `[${now}] Ejecutado: ${cmd} -> ${target.length} cliente(s)\n` + log.textContent;
        }

      } catch (e) {
        if (e && e.message === '401') return;
        const el = document.getElementById('modalResult');
        if (el) el.textContent = 'Error: ' + (e && e.message ? e.message : e);
      } finally {
        if (sendBtn) { sendBtn.disabled = false; sendBtn.style.opacity = ''; }
      }
    }

    // ------------------------
    // Limpiar modal (única implementación)
    // ------------------------
    function clearExecModal(ev) {
      try { if (ev && typeof ev.preventDefault === 'function') ev.preventDefault(); } catch (e) { }
      const input = document.getElementById('modalCmdInput');
      const timeout = document.getElementById('modalCmdTimeout');
      const url = document.getElementById('modalCmdUrl');
      const result = document.getElementById('modalResult');

      if (input) input.value = '';
      if (timeout) timeout.value = '10';
      if (url) url.value = '';

      // Usar renderResult para limpiar si existe
      if (typeof renderResult === 'function') {
        try { renderResult(''); } catch (e) { if (result) result.textContent = ''; }
      } else {
        if (result) result.textContent = '';
      }

      try { if (input) input.focus(); } catch (e) { }
    }

    // ------------------------
    // Persistencia de sesión
    // ------------------------
    function saveAuth(tok, rl) {
      token = tok;
      role = rl || null;
      try {
        localStorage.setItem('rm_token', tok);
        if (rl) localStorage.setItem('rm_role', rl);
        else localStorage.removeItem('rm_role');
      } catch (e) { console.warn('No se pudo guardar token:', e); }
    }

    function clearAuth() {
      token = null;
      role = null;
      try {
        localStorage.removeItem('rm_token');
        localStorage.removeItem('rm_role');
      } catch (e) { }
    }

    // ------------------------
    // UI: mostrar app / login
    // ------------------------
    function showAppUI() {
      try { document.getElementById('authOverlay').style.display = 'none'; } catch (e) { }
      try { document.querySelector('main.app').style.display = 'block'; } catch (e) { }
      try { document.getElementById('statusText').textContent = 'conectado'; } catch (e) { }

      // Añadir botón de logout si no existe
      try {
        const topBar = document.querySelector('.topBar');
        if (topBar && !document.getElementById('logoutBtn')) {
          const btn = document.createElement('button');
          btn.id = 'logoutBtn';
          btn.className = 'btn btn-ghost';
          btn.style.marginLeft = '12px';
          btn.textContent = 'Cerrar sesión';
          btn.onclick = logout;
          topBar.appendChild(btn);
        }
      } catch (e) { /* non-critical */ }

      // Inicializar toggle de comando/URL (si los elementos existen)
      try { initCmdUrlToggle(); } catch (e) { /* ignore */ }

      // Mostrar/ocultar botón "Gestionar usuarios"
      try {
        const storedRole = role || localStorage.getItem('rm_role');
        const manageBtn = document.getElementById('manageUsersBtn');
        if (manageBtn) {
          manageBtn.style.display = (storedRole === 'systems') ? 'inline-block' : 'none';
        }
      } catch (e) { /* ignore */ }
    }

    function showLoginUI() {
      try { document.getElementById('authOverlay').style.display = 'grid'; } catch (e) { }
      try { document.querySelector('main.app').style.display = 'none'; } catch (e) { }
      try { document.getElementById('statusText').textContent = 'desconectado'; } catch (e) { }
    }

    function handleAuthError(reason) {
      console.warn('Auth error:', reason);
      clearAuth();
      showLoginUI();
      const ls = document.getElementById('loginStatus');
      if (ls) ls.textContent = reason || 'Sesión inválida, vuelve a iniciar sesión.';
    }

    // ------------------------
    // authFetch: añade header Authorization y maneja 401
    // ------------------------
    async function authFetch(path, opts = {}) {
      opts = opts || {};
      opts.headers = opts.headers || {};
      if (token) opts.headers['Authorization'] = 'Bearer ' + token;
      // default JSON content-type when sending body and not provided
      if (opts.body && !opts.headers['Content-Type'] && !opts.headers['content-type']) {
        opts.headers['Content-Type'] = 'application/json';
      }
      const res = await fetch(path, opts);
      if (res.status === 401) {
        handleAuthError('Token inválido o expirado. Por favor inicia sesión de nuevo.');
        throw new Error('401');
      }
      return res;
    }

    // ------------------------
    // Login
    // ------------------------
    async function login() {
      const uEl = document.getElementById('username');
      const pEl = document.getElementById('password');
      const status = document.getElementById('loginStatus');
      if (status) status.textContent = '';

      const u = uEl ? (uEl.value || '').trim() : '';
      const p = pEl ? (pEl.value || '').trim() : '';
      if (!u || !p) { if (status) status.textContent = 'Ingresa usuario y contraseña.'; return; }

      try {
        const res = await fetch('/login', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ username: u, password: p }) });
        const text = await res.text().catch(() => '');
        let data = {};
        try { data = text ? JSON.parse(text) : {}; } catch (e) { data = {}; }

        if (res.ok) {
          const tok = data.access_token || null;
          const rl = data.role || null;
          if (!tok) {
            if (status) status.textContent = 'Respuesta de login sin token.';
            return;
          }
          saveAuth(tok, rl);
          showAppUI();
          if (status) status.textContent = '';
          try { await refreshClients(); } catch (e) { console.warn('refresh clients tras login falló', e); }
        } else {
          if (status) status.textContent = data.detail || text || `Error: ${res.status}`;
        }
      } catch (e) {
        if (document.getElementById('loginStatus')) document.getElementById('loginStatus').textContent = 'Error conectando al servidor: ' + e;
      }
    }

    // ------------------------
    // Client cards
    // ------------------------
    // === CREAR TILE (añade checkbox) ===
    function createClientTile(c) {
      const div = document.createElement('div');
      div.className = 'clientTile';
      div.setAttribute('role', 'button');
      div.setAttribute('aria-label', `Abrir cliente ${c.name || c.client_id || ''}`);
      div.tabIndex = 0;

      // checkbox absoluto (fuera del flujo visual)
      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.className = 'clientTileCheckbox';
      cb.title = 'Seleccionar cliente';
      cb.setAttribute('aria-label', `Seleccionar cliente ${c.name || c.client_id || ''}`);
      cb.addEventListener('click', function (ev) {
        ev.stopPropagation();
        if (typeof toggleSelectClient === 'function') {
          toggleSelectClient(c.client_id, cb.checked);
        }
      });
      div.appendChild(cb);

      // contenido principal (texto + badge dentro de meta)
      const content = document.createElement('div');
      content.className = 'clientContent';

      const meta = document.createElement('div');
      meta.className = 'clientMeta';

      const idEl = document.createElement('div');
      idEl.className = 'clientId';
      idEl.textContent = c.client_id || '';

      const nameEl = document.createElement('div');
      nameEl.className = 'clientName';
      nameEl.textContent = c.name || c.client_id || '(sin nombre)';

      const detailEl = document.createElement('div');
      detailEl.className = 'clientSmallHost';
      const parts = [];
      if (c.role) parts.push(c.role);
      if (c.hostname) parts.push(c.hostname);
      detailEl.textContent = parts.join(' · ') || '';

      // badge dentro de meta para que quede debajo del texto
      const badge = document.createElement('div');
      badge.className = c.connected ? 'statusBadge online' : 'statusBadge offline';
      badge.textContent = c.connected ? 'online' : 'offline';
      badge.setAttribute('aria-hidden', 'true');

      meta.appendChild(idEl);
      meta.appendChild(nameEl);
      meta.appendChild(detailEl);
      meta.appendChild(badge);

      content.appendChild(meta);
      div.appendChild(content);

      try {
        if (typeof selectedClients !== 'undefined' &&
          selectedClients &&
          typeof selectedClients.has === 'function' &&
          selectedClients.has(c.client_id)) {
          cb.checked = true;
        }
      } catch (err) { }

      div.addEventListener('click', () => {
        if (typeof openModal === 'function') openModal(c.client_id);
      });

      div.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          if (typeof openModal === 'function') openModal(c.client_id);
        }
      });

      return div;
    }

    // === POPULAR CARDS (igual que antes, pero respeta selección) ===
    function populateClientCards(clients, filter = '') {
      latestClients = clients || [];
      const grid = document.getElementById('clientsGrid');
      if (!grid) return;
      grid.innerHTML = '';

      // Add 'All' tile
      const allTile = document.createElement('div'); allTile.className = 'clientTile allTile';
      allTile.onclick = () => openModal('ALL');
      allTile.innerHTML = `<div class="allIcon">ALL</div><div style="font-weight:700">Enviar a todos</div><div class="small">Enviar mensaje o comando a todos los clientes</div>`;
      grid.appendChild(allTile);

      const q = (filter || '').trim().toLowerCase();
      for (const c of clients) {
        const text = `${c.client_id} ${c.name || ''} ${c.hostname || ''}`.toLowerCase();
        if (q && !text.includes(q)) continue;
        grid.appendChild(createClientTile(c));
      }

      try { document.getElementById('connectedCount').textContent = clients.filter(c => c.connected).length; } catch (e) { }
      try { document.getElementById('totalCount').textContent = clients.length; } catch (e) { }

      // si después del refresh algunos selected no existen, eliminarlos
      const validIds = new Set(clients.map(x => x.client_id));
      let removed = false;
      for (const id of Array.from(selectedClients)) {
        if (!validIds.has(id)) { selectedClients.delete(id); removed = true; }
      }
      if (removed) updateSelectionUI();
    }


    function applyFilter() { const q = document.getElementById('filterInput') ? document.getElementById('filterInput').value : ''; populateClientCards(latestClients, q); }

    // ------------------------
    // Refresh clients
    // ------------------------
    async function refreshClients() {
      if (!token) { alert('Inicia sesión primero'); return; }
      try {
        const res = await authFetch('/clients');
        if (!res.ok) {
          const text = await res.text().catch(() => '');
          let err = {};
          try { err = text ? JSON.parse(text) : {}; } catch (e) { err = {}; }
          alert('Error al obtener clientes: ' + (err.detail || res.status));
          return;
        }
        const text = await res.text().catch(() => '');
        let data = [];
        try { data = text ? JSON.parse(text) : []; } catch (e) { data = []; }
        latestClients = data;
        populateClientCards(data, document.getElementById('filterInput') ? document.getElementById('filterInput').value : '');
        const log = document.getElementById('logArea');
        if (log) log.textContent = `[${new Date().toLocaleTimeString()}] Clientes actualizados: ${data.length}\n` + log.textContent;
      } catch (e) {
        if (e && e.message === '401') return;
        alert('Error al refrescar clientes: ' + e);
      }
    }

    // ------------------------
    // Modal: open/close/tab switching
    // ------------------------
    // === OPEN / CLOSE MODAL: admitir array como target ===
    function openModal(clientIdOrArray) {
      // clientIdOrArray puede ser: 'ALL', 'c1', o Array(['c1','c2'])
      currentTarget = clientIdOrArray;
      try { document.getElementById('modalOverlay').style.display = 'grid'; } catch (e) { }
      try {
        const titleEl = document.getElementById('modalTitle');
        if (Array.isArray(clientIdOrArray)) titleEl.textContent = `Enviar a ${clientIdOrArray.length} seleccionados`;
        else titleEl.textContent = clientIdOrArray === 'ALL' ? 'Enviar a todos' : 'Cliente';
      } catch (e) { }
      try {
        const subEl = document.getElementById('modalSub');
        if (Array.isArray(clientIdOrArray)) subEl.textContent = `IDs: ${clientIdOrArray.join(', ')}`;
        else subEl.textContent = 'ID: ' + clientIdOrArray;
      } catch (e) { }
      try { document.getElementById('modalResult').textContent = ''; } catch (e) { }
      try { document.getElementById('modalMessage').value = ''; } catch (e) { }
      try { document.getElementById('modalCmdInput').value = ''; } catch (e) { }
      try { document.getElementById('modalCmdTimeout').value = '10'; } catch (e) { }
      try { clearExecModal(); } catch (e) { /* ignore */ }

      // show/hide screen tab: SOLO disponible si target es un único cliente (string distinto de 'ALL')
      const tabScreen = document.getElementById('tabScreen');
      if (tabScreen) {
        const isSingleClient = (typeof currentTarget === 'string' && currentTarget !== 'ALL');
        tabScreen.style.display = isSingleClient ? 'inline-block' : 'none';
      }

      // hide command tab if user role is not systems (mantén tu lógica)
      const tabCmd = document.getElementById('tabCmd');
      const userRole = role || localStorage.getItem('rm_role');
      if (tabCmd) {
        if (userRole !== 'systems') {
          tabCmd.style.display = 'none';
          const panelCmd = document.getElementById('panelCmd');
          if (panelCmd) panelCmd.style.display = 'none';
          tabCmd.classList.remove('active');
          const tabMsg = document.getElementById('tabMsg');
          if (tabMsg) tabMsg.classList.add('active');
        } else {
          tabCmd.style.display = 'inline-block';
        }
      }

      switchTab('msg');
    }


    function closeModal() { stopLocalScreenRefresh(); try { document.getElementById('modalOverlay').style.display = 'none'; } catch (e) { } currentTarget = null; }

    function switchTab(which) {
      try { document.getElementById('panelMsg').style.display = which === 'msg' ? 'block' : 'none'; } catch (e) { }
      try { document.getElementById('panelCmd').style.display = which === 'cmd' ? 'block' : 'none'; } catch (e) { }
      try { document.getElementById('panelScreen').style.display = which === 'screen' ? 'block' : 'none'; } catch (e) { }
      try { document.getElementById('tabMsg').classList.toggle('active', which === 'msg'); } catch (e) { }
      try { document.getElementById('tabCmd').classList.toggle('active', which === 'cmd'); } catch (e) { }
      try { document.getElementById('tabScreen').classList.toggle('active', which === 'screen'); } catch (e) { }

      if (which !== 'screen') stopLocalScreenRefresh();
      if (which === 'screen') {
        const ph = document.getElementById('screenPlaceholder');
        const img = document.getElementById('screenImg');
        if (ph) ph.style.display = (img && img.src && img.style.display === 'block') ? 'none' : 'flex';
      }
    }

    // ------------------------
    // Send message modal
    // ------------------------
    async function sendMessageModal() {
      const msgEl = document.getElementById('modalMessage');
      const msg = msgEl ? (msgEl.value || '').trim() : '';
      if (!msg) { alert('Escribe un mensaje.'); return; }

      const target = Array.isArray(currentTarget)
        ? currentTarget.slice()
        : (currentTarget === 'ALL'
          ? latestClients.map(c => c.client_id).filter(Boolean)
          : [currentTarget]);
      if (!target || target.length === 0) { alert('Selecciona un cliente'); return; }

      const typeEl = document.querySelector('input[name="messageType"]:checked');
      const messageType = typeEl ? typeEl.value : 'fixed';
      const timeoutEl = document.getElementById('modalTimeout');
      const timeoutSeconds = (messageType === 'temporary' && timeoutEl && parseInt(timeoutEl.value, 10) > 0) ? parseInt(timeoutEl.value, 10) : null;

      const payload = {
        client_ids: target,
        message: msg,
        message_type: messageType
      };
      if (timeoutSeconds !== null) payload.timeout_seconds = timeoutSeconds;

      const sendBtn = document.getElementById('sendMessageBtn');
      if (sendBtn) { sendBtn.disabled = true; sendBtn.style.opacity = '0.7'; }

      try {
        const res = await authFetch('/send_message', {
          method: 'POST',
          body: JSON.stringify(payload)
        });

        const ct = res.headers.get('content-type') || '';
        const text = await res.text().catch(() => '');
        if (!res.ok) {
          const err = text || 'Error desconocido';
          document.getElementById('modalResult').textContent = err;
          return;
        }

        let data = text;
        if (text && ct.includes('application/json')) {
          try { data = JSON.parse(text); } catch (e) { /* keep text */ }
        }

        document.getElementById('modalResult').textContent = typeof data === 'string' ? data : JSON.stringify(data, null, 2);
        const log = document.getElementById('logArea');
        if (log) log.textContent =
          `[${new Date().toLocaleTimeString()}] Mensaje enviado a ${target.length} cliente(s) (${messageType}${timeoutSeconds ? ' - ' + timeoutSeconds + 's' : ''})\n`
          + log.textContent;

      } catch (e) {
        if (e && e.message === '401') return;
        document.getElementById('modalResult').textContent = 'Error: ' + (e && e.message ? e.message : e);
      } finally {
        if (sendBtn) { sendBtn.disabled = false; sendBtn.style.opacity = ''; }
      }
    }

    // ------------------------
    // Init message type controls (delegación)
    // ------------------------
    (function initMessageTypeControls() {
      const modalOverlay = document.getElementById('modalOverlay');
      if (!modalOverlay) return;
      modalOverlay.addEventListener('change', function (ev) {
        try {
          const t = ev.target;
          if (!t) return;
          if (t.name === 'messageType') {
            const timeoutInput = document.getElementById('modalTimeout');
            if (!timeoutInput) return;
            if (t.value === 'temporary') {
              timeoutInput.disabled = false;
              if (!timeoutInput.value) timeoutInput.value = '5';
              timeoutInput.focus();
            } else {
              timeoutInput.disabled = true;
            }
          }
        } catch (err) { console.warn('initMessageTypeControls error', err); }
      });
    })();

    // === MULTI-SELECTION SUPPORT ===
    let selectedClients = new Set();

    // toggle (marca/desmarca) un cliente
    function toggleSelectClient(clientId, checked) {
      if (!clientId) return;
      if (checked) selectedClients.add(clientId);
      else selectedClients.delete(clientId);
      updateSelectionUI();
    }

    // actualiza UI: contador y botones
    function updateSelectionUI() {
      const count = selectedClients.size;
      const btn = document.getElementById('sendSelectedBtn');
      const clearBtn = document.getElementById('clearSelectedBtn');
      const counter = document.getElementById('selectedCount');
      if (counter) counter.textContent = count;
      if (btn) btn.style.display = count > 0 ? 'inline-flex' : 'none';
      if (clearBtn) clearBtn.style.display = count > 0 ? 'inline-flex' : 'none';
    }

    // limpia selección
    function clearSelection() {
      selectedClients.clear();
      document.querySelectorAll('.clientTile input[type="checkbox"]').forEach(cb => cb.checked = false);
      updateSelectionUI();
    }

    // abrir modal para los seleccionados
    function openModalForSelected() {
      if (selectedClients.size === 0) { alert('No hay clientes seleccionados.'); return; }
      openModal(Array.from(selectedClients));
    }


    // ------------------------
    // Screen viewing functions
    // ------------------------
    async function startScreenStream() {
      if (!token) { alert('Inicia sesión'); return; }
      if (!currentTarget || currentTarget === 'ALL' || Array.isArray(currentTarget)) { alert('Selecciona un cliente individual'); return; }
      try {
        const res = await authFetch(`/clients/${currentTarget}/screen/start`, { method: 'POST' });
        if (!res.ok) {
          const text = await res.text().catch(() => '');
          let err = {};
          try { err = text ? JSON.parse(text) : {}; } catch (e) { err = {}; }
          alert('Error iniciando stream: ' + (err.detail || res.status));
          return;
        }
        const log = document.getElementById('logArea');
        if (log) log.textContent = `[${new Date().toLocaleTimeString()}] Solicitud de inicio de transmisión enviada a ${currentTarget}\n` + log.textContent;
        startLocalScreenRefresh();
      } catch (e) { if (e && e.message === '401') return; alert('Error: ' + e); }
    }

    async function stopScreenStream() {
      if (!token) { alert('Inicia sesión'); return; }
      if (!currentTarget || currentTarget === 'ALL' || Array.isArray(currentTarget)) { alert('Selecciona un cliente individual'); return; }
      try {
        const res = await authFetch(`/clients/${currentTarget}/screen/stop`, { method: 'POST' });
        if (!res.ok) {
          const text = await res.text().catch(() => '');
          let err = {};
          try { err = text ? JSON.parse(text) : {}; } catch (e) { err = {}; }
          alert('Error deteniendo stream: ' + (err.detail || res.status));
          return;
        }
        const log = document.getElementById('logArea');
        if (log) log.textContent = `[${new Date().toLocaleTimeString()}] Solicitud de detención de transmisión enviada a ${currentTarget}\n` + log.textContent;
        stopLocalScreenRefresh();
      } catch (e) { if (e && e.message === '401') return; alert('Error: ' + e); }
    }

    function stopLocalScreenRefresh() {
      screenRefreshId++;
      if (screenInterval) { clearInterval(screenInterval); screenInterval = null; }

      const img = document.getElementById('screenImg');
      const ph = document.getElementById('screenPlaceholder');
      const spinner = document.getElementById('screenSpinner');

      if (img) {
        try { img.onload = null; img.onerror = null; } catch (e) { }
        img.style.display = 'none';
        img.src = '';
      }

      if (previousObjectUrl) {
        try { URL.revokeObjectURL(previousObjectUrl); } catch (e) { console.warn('Error revoking previousObjectUrl', e); }
        previousObjectUrl = null;
      }

      if (spinner) { spinner.style.display = 'none'; spinner.setAttribute('aria-hidden', 'true'); }
      if (ph) ph.style.display = 'flex';
    }

    function startLocalScreenRefresh() {
      if (!token) return;
      if (!currentTarget || currentTarget === 'ALL') return;

      screenRefreshId++;
      const myId = screenRefreshId;

      if (screenInterval) { clearInterval(screenInterval); screenInterval = null; }

      const fpsEl = document.getElementById('screenFps');
      const fps = fpsEl ? (parseInt(fpsEl.value, 10) || 2) : 2;
      const interval = Math.max(200, Math.round(1000 / fps));

      const spinner = document.getElementById('screenSpinner');
      const ph = document.getElementById('screenPlaceholder');
      if (spinner) { spinner.style.display = 'flex'; spinner.setAttribute('aria-hidden', 'false'); }
      if (ph) { ph.style.display = 'flex'; }

      // first fetch immediately
      fetchAndSetFrame(myId);
      screenInterval = setInterval(() => fetchAndSetFrame(myId), interval);
    }

    async function fetchAndSetFrame(myId) {
      if (myId !== screenRefreshId) return;
      if (!token) return;
      if (!currentTarget || currentTarget === 'ALL') return;

      try {
        const url = `/clients/${currentTarget}/screen?t=${Date.now()}`;
        const res = await authFetch(url, { cache: 'no-store' });

        if (myId !== screenRefreshId) return;

        if (!res.ok) {
          if (res.status === 404) return;
          const text = await res.text().catch(() => '');
          console.warn('Error fetching frame', res.status, text);
          return;
        }

        const blob = await res.blob();
        if (!blob) return;

        const newUrl = URL.createObjectURL(blob);
        const img = document.getElementById('screenImg');
        const ph = document.getElementById('screenPlaceholder');
        const spinner = document.getElementById('screenSpinner');

        if (!img) {
          try { URL.revokeObjectURL(newUrl); } catch (e) { }
          return;
        }

        img.onload = function () {
          try {
            if (myId !== screenRefreshId) {
              try { URL.revokeObjectURL(newUrl); } catch (e) { }
              return;
            }
            if (previousObjectUrl && previousObjectUrl !== newUrl) {
              try { URL.revokeObjectURL(previousObjectUrl); } catch (e) { console.warn('revoking previous', e); }
            }
            previousObjectUrl = newUrl;
            img.style.display = 'block';
            if (ph) ph.style.display = 'none';
            if (spinner) { spinner.style.display = 'none'; spinner.setAttribute('aria-hidden', 'true'); }
          } catch (e) {
            console.error('onload handler error', e);
          } finally {
            img.onload = null;
          }
        };

        img.onerror = function () {
          try { URL.revokeObjectURL(newUrl); } catch (e) { }
          if (myId === screenRefreshId) {
            img.style.display = 'none';
            if (ph) ph.style.display = 'flex';
            if (spinner) { spinner.style.display = 'none'; spinner.setAttribute('aria-hidden', 'true'); }
          }
          img.onerror = null;
        };

        img.src = newUrl;
      } catch (e) {
        if (e && e.message === '401') return;
        console.error('Error fetching frame', e);
        const spinner = document.getElementById('screenSpinner');
        if (spinner) { spinner.style.display = 'none'; spinner.setAttribute('aria-hidden', 'true'); }
      }
    }

    // ------------------------
    // Logout
    // ------------------------
    function logout() {
      clearAuth();
      stopLocalScreenRefresh();
      showLoginUI();
      const ls = document.getElementById('loginStatus');
      if (ls) ls.textContent = 'Sesión cerrada.';
    }

    // ------------------------
    // Init: restaurar sesión si hay token en localStorage
    // ------------------------
    window.addEventListener('load', async () => {
      try {
        const saved = localStorage.getItem('rm_token');
        const savedRole = localStorage.getItem('rm_role');
        if (saved) {
          token = saved;
          role = savedRole;
          showAppUI();
          try { await refreshClients(); } catch (e) { console.warn('refreshClients falló al restaurar sesión', e); }
        } else {
          showLoginUI();
        }
      } catch (e) {
        console.error('Error al restaurar sesión:', e);
        showLoginUI();
      }
    });

    // ------------------------
    // Opcional: demo/dev clients (descomenta para desarrollo local sin backend)
    // ------------------------
    // window.addEventListener('load',()=>{ latestClients=[{client_id:'c1',name:'Cliente A',hostname:'host-a',connected:true},{client_id:'c2',name:'Cliente B',hostname:'host-b',connected:false},{client_id:'c3',name:'Cliente C',hostname:'host-c',connected:true}]; populateClientCards(latestClients); document.querySelector('main.app').style.display='block'; });

  </script>

</body>

</html>